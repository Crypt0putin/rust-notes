# üß¨ –û–±–æ–±—â—ë–Ω–Ω–æ–µ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–µ (Generics)

## üìã –°–æ–¥–µ—Ä–∂–∞–Ω–∏–µ —Ä–∞–∑–¥–µ–ª–∞

1. [–ß—Ç–æ —Ç–∞–∫–æ–µ –æ–±–æ–±—â–µ–Ω–∏—è](#—á—Ç–æ-—Ç–∞–∫–æ–µ-–æ–±–æ–±—â–µ–Ω–∏—è)
2. [Generic —Ñ—É–Ω–∫—Ü–∏–∏](#generic-—Ñ—É–Ω–∫—Ü–∏–∏)
3. [Generic —Å—Ç—Ä—É–∫—Ç—É—Ä—ã](#generic-—Å—Ç—Ä—É–∫—Ç—É—Ä—ã)
4. [Generic –µ–Ω—É–º—ã](#generic-–µ–Ω—É–º—ã)
5. [Generic –º–µ—Ç–æ–¥—ã](#generic-–º–µ—Ç–æ–¥—ã)
6. [–û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è —Ç—Ä–µ–π—Ç–æ–≤](#–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è-—Ç—Ä–µ–π—Ç–æ–≤)
7. [Associated types](#associated-types)

## üéØ –ß—Ç–æ —Ç–∞–∫–æ–µ –æ–±–æ–±—â–µ–Ω–∏—è?

**–û–±–æ–±—â–µ–Ω–∏—è (Generics)** –ø–æ–∑–≤–æ–ª—è—é—Ç –ø–∏—Å–∞—Ç—å –∫–æ–¥, –∫–æ—Ç–æ—Ä—ã–π —Ä–∞–±–æ—Ç–∞–µ—Ç —Å —Ä–∞–∑–Ω—ã–º–∏ —Ç–∏–ø–∞–º–∏ –±–µ–∑ –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è. –≠—Ç–æ —Å–ø–æ—Å–æ–± –∞–±—Å—Ç—Ä–∞–≥–∏—Ä–æ–≤–∞—Ç—å—Å—è –æ—Ç –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã—Ö —Ç–∏–ø–æ–≤.

### –ü—Ä–æ–±–ª–µ–º–∞ –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è
```rust
// ‚ùå –ü–ª–æ—Ö–æ: –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–æ–¥–∞
fn –Ω–∞–∏–±–æ–ª—å—à–µ–µ_i32(—Å–ø–∏—Å–æ–∫: &[i32]) -> i32 {
    let mut –Ω–∞–∏–±–æ–ª—å—à–µ–µ = —Å–ø–∏—Å–æ–∫[0];
    for &—ç–ª–µ–º–µ–Ω—Ç in —Å–ø–∏—Å–æ–∫ {
        if —ç–ª–µ–º–µ–Ω—Ç > –Ω–∞–∏–±–æ–ª—å—à–µ–µ {
            –Ω–∞–∏–±–æ–ª—å—à–µ–µ = —ç–ª–µ–º–µ–Ω—Ç;
        }
    }
    –Ω–∞–∏–±–æ–ª—å—à–µ–µ
}

fn –Ω–∞–∏–±–æ–ª—å—à–µ–µ_char(—Å–ø–∏—Å–æ–∫: &[char]) -> char {
    let mut –Ω–∞–∏–±–æ–ª—å—à–µ–µ = —Å–ø–∏—Å–æ–∫[0];
    for &—ç–ª–µ–º–µ–Ω—Ç in —Å–ø–∏—Å–æ–∫ {
        if —ç–ª–µ–º–µ–Ω—Ç > –Ω–∞–∏–±–æ–ª—å—à–µ–µ {
            –Ω–∞–∏–±–æ–ª—å—à–µ–µ = —ç–ª–µ–º–µ–Ω—Ç;
        }
    }
    –Ω–∞–∏–±–æ–ª—å—à–µ–µ
}

// ‚úÖ –•–æ—Ä–æ—à–æ: –æ–±–æ–±—â—ë–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è
fn –Ω–∞–∏–±–æ–ª—å—à–µ–µ<T: PartialOrd>(—Å–ø–∏—Å–æ–∫: &[T]) -> &T {
    let mut –Ω–∞–∏–±–æ–ª—å—à–µ–µ = &—Å–ø–∏—Å–æ–∫[0];
    for —ç–ª–µ–º–µ–Ω—Ç in —Å–ø–∏—Å–æ–∫ {
        if —ç–ª–µ–º–µ–Ω—Ç > –Ω–∞–∏–±–æ–ª—å—à–µ–µ {
            –Ω–∞–∏–±–æ–ª—å—à–µ–µ = —ç–ª–µ–º–µ–Ω—Ç;
        }
    }
    –Ω–∞–∏–±–æ–ª—å—à–µ–µ
}
```

## üîß Generic —Ñ—É–Ω–∫—Ü–∏–∏

### –ë–∞–∑–æ–≤—ã–π —Å–∏–Ω—Ç–∞–∫—Å–∏—Å
```rust
// –û–¥–∏–Ω generic –ø–∞—Ä–∞–º–µ—Ç—Ä
fn –∏–¥–µ–Ω—Ç–∏—á–Ω–æ—Å—Ç—å<T>(–∑–Ω–∞—á–µ–Ω–∏–µ: T) -> T {
    –∑–Ω–∞—á–µ–Ω–∏–µ
}

// –ù–µ—Å–∫–æ–ª—å–∫–æ generic –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
fn –æ–±–º–µ–Ω—è—Ç—å<T, U>(–ø–µ—Ä–≤—ã–π: T, –≤—Ç–æ—Ä–æ–π: U) -> (U, T) {
    (–≤—Ç–æ—Ä–æ–π, –ø–µ—Ä–≤—ã–π)
}

fn main() {
    let —á–∏—Å–ª–æ = –∏–¥–µ–Ω—Ç–∏—á–Ω–æ—Å—Ç—å(5);
    let —Å—Ç—Ä–æ–∫–∞ = –∏–¥–µ–Ω—Ç–∏—á–Ω–æ—Å—Ç—å("–ø—Ä–∏–≤–µ—Ç");
    
    let (a, b) = –æ–±–º–µ–Ω—è—Ç—å(5, "—Å—Ç—Ä–æ–∫–∞");
    println!("a: {}, b: {}", a, b); // a: —Å—Ç—Ä–æ–∫–∞, b: 5
}
```

### Generic —Å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è–º–∏
```rust
use std::fmt::Display;

// T –¥–æ–ª–∂–µ–Ω —Ä–µ–∞–ª–∏–∑–æ–≤—ã–≤–∞—Ç—å Display
fn –ø–æ–∫–∞–∑–∞—Ç—å<T: Display>(–∑–Ω–∞—á–µ–Ω–∏–µ: T) {
    println!("–ó–Ω–∞—á–µ–Ω–∏–µ: {}", –∑–Ω–∞—á–µ–Ω–∏–µ);
}

// –ù–µ—Å–∫–æ–ª—å–∫–æ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π
fn –ø–æ–∫–∞–∑–∞—Ç—å_–∏_–∫–ª–æ–Ω–∏—Ä–æ–≤–∞—Ç—å<T: Display + Clone>(–∑–Ω–∞—á–µ–Ω–∏–µ: T) -> T {
    println!("–ó–Ω–∞—á–µ–Ω–∏–µ: {}", –∑–Ω–∞—á–µ–Ω–∏–µ);
    –∑–Ω–∞—á–µ–Ω–∏–µ.clone()
}

// where —Å–∏–Ω—Ç–∞–∫—Å–∏—Å –¥–ª—è —á–∏—Ç–∞–µ–º–æ—Å—Ç–∏
fn —Å–ª–æ–∂–Ω–∞—è_—Ñ—É–Ω–∫—Ü–∏—è<T, U>(t: &T, u: &U) -> i32
where
    T: Display + Clone,
    U: Clone + std::fmt::Debug,
{
    println!("t: {}", t);
    println!("u: {:?}", u);
    42
}
```

### –ü—Ä–∏–º–µ—Ä—ã –ø–æ–ª–µ–∑–Ω—ã—Ö generic —Ñ—É–Ω–∫—Ü–∏–π
```rust
// –ü–æ–∏—Å–∫ —ç–ª–µ–º–µ–Ω—Ç–∞
fn –Ω–∞–π—Ç–∏<T: PartialEq>(—Å—Ä–µ–∑: &[T], –∏—Å–∫–æ–º–æ–µ: &T) -> Option<usize> {
    for (–∏–Ω–¥–µ–∫—Å, —ç–ª–µ–º–µ–Ω—Ç) in —Å—Ä–µ–∑.iter().enumerate() {
        if —ç–ª–µ–º–µ–Ω—Ç == –∏—Å–∫–æ–º–æ–µ {
            return Some(–∏–Ω–¥–µ–∫—Å);
        }
    }
    None
}

// –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è
fn —Ñ–∏–ª—å—Ç—Ä–æ–≤–∞—Ç—å<T, F>(–≤–µ–∫—Ç–æ—Ä: Vec<T>, –ø—Ä–µ–¥–∏–∫–∞—Ç: F) -> Vec<T>
where
    F: Fn(&T) -> bool,
{
    let mut —Ä–µ–∑—É–ª—å—Ç–∞—Ç = Vec::new();
    for —ç–ª–µ–º–µ–Ω—Ç in –≤–µ–∫—Ç–æ—Ä {
        if –ø—Ä–µ–¥–∏–∫–∞—Ç(&—ç–ª–µ–º–µ–Ω—Ç) {
            —Ä–µ–∑—É–ª—å—Ç–∞—Ç.push(—ç–ª–µ–º–µ–Ω—Ç);
        }
    }
    —Ä–µ–∑—É–ª—å—Ç–∞—Ç
}

// –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ
fn –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç—å<T, U, F>(–≤–µ–∫—Ç–æ—Ä: Vec<T>, —Ñ—É–Ω–∫—Ü–∏—è: F) -> Vec<U>
where
    F: Fn(T) -> U,
{
    let mut —Ä–µ–∑—É–ª—å—Ç–∞—Ç = Vec::new();
    for —ç–ª–µ–º–µ–Ω—Ç in –≤–µ–∫—Ç–æ—Ä {
        —Ä–µ–∑—É–ª—å—Ç–∞—Ç.push(—Ñ—É–Ω–∫—Ü–∏—è(—ç–ª–µ–º–µ–Ω—Ç));
    }
    —Ä–µ–∑—É–ª—å—Ç–∞—Ç
}
```

## üèóÔ∏è Generic —Å—Ç—Ä—É–∫—Ç—É—Ä—ã

### –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ generic —Å—Ç—Ä—É–∫—Ç—É—Ä
```rust
// –°—Ç—Ä—É–∫—Ç—É—Ä–∞ —Å –æ–¥–Ω–∏–º generic —Ç–∏–ø–æ–º
struct –¢–æ—á–∫–∞<T> {
    x: T,
    y: T,
}

// –°—Ç—Ä—É–∫—Ç—É—Ä–∞ —Å –Ω–µ—Å–∫–æ–ª—å–∫–∏–º–∏ generic —Ç–∏–ø–∞–º–∏
struct –ü–∞—Ä–∞<T, U> {
    –ø–µ—Ä–≤—ã–π: T,
    –≤—Ç–æ—Ä–æ–π: U,
}

fn main() {
    // –ö–æ–Ω–∫—Ä–µ—Ç–Ω—ã–µ —Ç–∏–ø—ã –≤—ã–≤–æ–¥—è—Ç—Å—è
    let —Ü–µ–ª–∞—è = –¢–æ—á–∫–∞ { x: 5, y: 10 };
    let –¥—Ä–æ–±–Ω–∞—è = –¢–æ—á–∫–∞ { x: 1.0, y: 4.0 };
    
    let —Å–º–µ—à–∞–Ω–Ω–∞—è = –ü–∞—Ä–∞ {
        –ø–µ—Ä–≤—ã–π: 5,
        –≤—Ç–æ—Ä–æ–π: "—Å—Ç—Ä–æ–∫–∞",
    };
}
```

### –†–µ–∞–ª–∏–∑–∞—Ü–∏—è –º–µ—Ç–æ–¥–æ–≤ –¥–ª—è generic —Å—Ç—Ä—É–∫—Ç—É—Ä
```rust
struct –¢–æ—á–∫–∞<T> {
    x: T,
    y: T,
}

// impl –±–ª–æ–∫ –¥–ª—è –ª—é–±–æ–≥–æ T
impl<T> –¢–æ—á–∫–∞<T> {
    fn –Ω–æ–≤–∞—è(x: T, y: T) -> Self {
        –¢–æ—á–∫–∞ { x, y }
    }
    
    fn x(&self) -> &T {
        &self.x
    }
}

// impl –±–ª–æ–∫ —Ç–æ–ª—å–∫–æ –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ —Ç–∏–ø–∞
impl –¢–æ—á–∫–∞<f32> {
    fn —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ_–æ—Ç_–Ω–∞—á–∞–ª–∞(&self) -> f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}

// impl —Å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è–º–∏
impl<T: Display + PartialOrd> –¢–æ—á–∫–∞<T> {
    fn —Å—Ä–∞–≤–Ω–∏—Ç—å_–∏_–ø–æ–∫–∞–∑–∞—Ç—å(&self) {
        if self.x > self.y {
            println!("x –±–æ–ª—å—à–µ: {}", self.x);
        } else {
            println!("y –±–æ–ª—å—à–µ –∏–ª–∏ —Ä–∞–≤–µ–Ω: {}", self.y);
        }
    }
}
```

### –ú–µ—Ç–æ–¥—ã —Å —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–º–∏ generic –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏
```rust
impl<T> –¢–æ—á–∫–∞<T> {
    fn —Å–º–µ—à–∞—Ç—å<U>(self, –¥—Ä—É–≥–∞—è: –¢–æ—á–∫–∞<U>) -> –¢–æ—á–∫–∞<U> {
        –¢–æ—á–∫–∞ {
            x: –¥—Ä—É–≥–∞—è.x,
            y: –¥—Ä—É–≥–∞—è.y,
        }
    }
}

fn main() {
    let p1 = –¢–æ—á–∫–∞ { x: 5, y: 10.4 };
    let p2 = –¢–æ—á–∫–∞ { x: "–ü—Ä–∏–≤–µ—Ç", y: 'c' };
    
    let p3 = p1.—Å–º–µ—à–∞—Ç—å(p2);
    println!("p3.x = {}, p3.y = {}", p3.x, p3.y);
}
```

## üé≠ Generic –µ–Ω—É–º—ã

### Option –∏ Result - –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–µ generic –µ–Ω—É–º—ã
```rust
// –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ Option
enum Option<T> {
    Some(T),
    None,
}

// –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ Result
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

### –°–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–µ generic –µ–Ω—É–º—ã
```rust
// –ë–∏–Ω–∞—Ä–Ω–æ–µ –¥–µ—Ä–µ–≤–æ
enum –ë–∏–Ω–∞—Ä–Ω–æ–µ–î–µ—Ä–µ–≤–æ<T> {
    –ü—É—Å—Ç–æ,
    –£–∑–µ–ª {
        –∑–Ω–∞—á–µ–Ω–∏–µ: T,
        –ª–µ–≤—ã–π: Box<–ë–∏–Ω–∞—Ä–Ω–æ–µ–î–µ—Ä–µ–≤–æ<T>>,
        –ø—Ä–∞–≤—ã–π: Box<–ë–∏–Ω–∞—Ä–Ω–æ–µ–î–µ—Ä–µ–≤–æ<T>>,
    },
}

// –°–ø–∏—Å–æ–∫
enum –°–ø–∏—Å–æ–∫<T> {
    –ö–æ–Ω–µ—Ü,
    –≠–ª–µ–º–µ–Ω—Ç(T, Box<–°–ø–∏—Å–æ–∫<T>>),
}

impl<T> –°–ø–∏—Å–æ–∫<T> {
    fn –Ω–æ–≤—ã–π() -> Self {
        –°–ø–∏—Å–æ–∫::–ö–æ–Ω–µ—Ü
    }
    
    fn –¥–æ–±–∞–≤–∏—Ç—å(self, —ç–ª–µ–º–µ–Ω—Ç: T) -> Self {
        –°–ø–∏—Å–æ–∫::–≠–ª–µ–º–µ–Ω—Ç(—ç–ª–µ–º–µ–Ω—Ç, Box::new(self))
    }
}
```

## üîí –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è —Ç—Ä–µ–π—Ç–æ–≤ (Trait Bounds)

### –ë–∞–∑–æ–≤—ã–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è
```rust
use std::fmt::Debug;

// T –¥–æ–ª–∂–µ–Ω —Ä–µ–∞–ª–∏–∑–æ–≤—ã–≤–∞—Ç—å Debug
fn –Ω–∞–ø–µ—á–∞—Ç–∞—Ç—å_–æ—Ç–ª–∞–¥–∫—É<T: Debug>(–∑–Ω–∞—á–µ–Ω–∏–µ: T) {
    println!("{:?}", –∑–Ω–∞—á–µ–Ω–∏–µ);
}

// –ù–µ—Å–∫–æ–ª—å–∫–æ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π —Å +
fn –∫–ª–æ–Ω–∏—Ä–æ–≤–∞—Ç—å_–∏_—Å—Ä–∞–≤–Ω–∏—Ç—å<T: Clone + PartialEq>(a: &T, b: &T) -> bool {
    let –∫–ª–æ–Ω_a = a.clone();
    –∫–ª–æ–Ω_a == *b
}
```

### where —É—Å–ª–æ–≤–∏—è
```rust
use std::fmt::Display;

fn –∫–∞–∫–∞—è_—Ç–æ_—Ñ—É–Ω–∫—Ü–∏—è<T, U>(t: &T, u: &U) -> i32
where
    T: Display + Clone,
    U: Clone + Debug,
{
    // —Ç–µ–ª–æ —Ñ—É–Ω–∫—Ü–∏–∏
}

// –û—Å–æ–±–µ–Ω–Ω–æ –ø–æ–ª–µ–∑–Ω–æ –¥–ª—è —Å–ª–æ–∂–Ω—ã—Ö –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π
fn –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å<T, U>(–∑–Ω–∞—á–µ–Ω–∏–µ: T) -> U
where
    T: Into<U>,
    U: From<T>,
{
    U::from(–∑–Ω–∞—á–µ–Ω–∏–µ)
}
```

### –£—Å–ª–æ–≤–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è
```rust
use std::fmt::Display;

struct –ü–∞—Ä–∞<T> {
    x: T,
    y: T,
}

// –†–µ–∞–ª–∏–∑–∞—Ü–∏—è new –¥–ª—è –ª—é–±–æ–≥–æ T
impl<T> –ü–∞—Ä–∞<T> {
    fn –Ω–æ–≤–∞—è(x: T, y: T) -> Self {
        –ü–∞—Ä–∞ { x, y }
    }
}

// –†–µ–∞–ª–∏–∑–∞—Ü–∏—è cmp_display —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ T: Display + PartialOrd
impl<T: Display + PartialOrd> –ü–∞—Ä–∞<T> {
    fn cmp_display(&self) {
        if self.x >= self.y {
            println!("–ù–∞–∏–±–æ–ª—å—à–∏–π: {}", self.x);
        } else {
            println!("–ù–∞–∏–±–æ–ª—å—à–∏–π: {}", self.y);
        }
    }
}
```

### Blanket implementations
```rust
// –†–µ–∞–ª–∏–∑–∞—Ü–∏—è —Ç—Ä–µ–π—Ç–∞ –¥–ª—è –≤—Å–µ—Ö —Ç–∏–ø–æ–≤, —É–¥–æ–≤–ª–µ—Ç–≤–æ—Ä—è—é—â–∏—Ö —É—Å–ª–æ–≤–∏—é
impl<T: Display> ToString for T {
    fn to_string(&self) -> String {
        format!("{}", self)
    }
}
```

## üîó Associated Types

### –ü—Ä–æ–±–ª–µ–º–∞ —Å generics –≤ —Ç—Ä–µ–π—Ç–∞—Ö
```rust
// –° generic –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–º - –Ω—É–∂–Ω–æ —É–∫–∞–∑—ã–≤–∞—Ç—å —Ç–∏–ø –∫–∞–∂–¥—ã–π —Ä–∞–∑
trait –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä<T> {
    fn –¥–æ–±–∞–≤–∏—Ç—å(&mut self, —ç–ª–µ–º–µ–Ω—Ç: T);
    fn –ø–æ–ª—É—á–∏—Ç—å(&self) -> Option<&T>;
}

// –° associated type - —Ç–∏–ø –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç—Å—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–µ–π
trait –ö–æ–Ω—Ç–µ–π–Ω–µ—ÄV2 {
    type –≠–ª–µ–º–µ–Ω—Ç;
    
    fn –¥–æ–±–∞–≤–∏—Ç—å(&mut self, —ç–ª–µ–º–µ–Ω—Ç: Self::–≠–ª–µ–º–µ–Ω—Ç);
    fn –ø–æ–ª—É—á–∏—Ç—å(&self) -> Option<&Self::–≠–ª–µ–º–µ–Ω—Ç>;
}
```

### –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ associated types
```rust
trait Iterator {
    type Item;
    
    fn next(&mut self) -> Option<Self::Item>;
}

struct –°—á—ë—Ç—á–∏–∫ {
    —Å—á—ë—Ç: u32,
}

impl Iterator for –°—á—ë—Ç—á–∏–∫ {
    type Item = u32;
    
    fn next(&mut self) -> Option<Self::Item> {
        self.—Å—á—ë—Ç += 1;
        if self.—Å—á—ë—Ç < 6 {
            Some(self.—Å—á—ë—Ç)
        } else {
            None
        }
    }
}
```

## üíª –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ –ø—Ä–∏–º–µ—Ä—ã

### Generic –∫–µ—à
```rust
use std::collections::HashMap;
use std::hash::Hash;

struct –ö–µ—à<K, V> {
    –¥–∞–Ω–Ω—ã–µ: HashMap<K, V>,
    –º–∞–∫—Å–∏–º—É–º: usize,
}

impl<K: Hash + Eq, V> –ö–µ—à<K, V> {
    fn –Ω–æ–≤—ã–π(–º–∞–∫—Å–∏–º—É–º: usize) -> Self {
        –ö–µ—à {
            –¥–∞–Ω–Ω—ã–µ: HashMap::new(),
            –º–∞–∫—Å–∏–º—É–º,
        }
    }
    
    fn –≤—Å—Ç–∞–≤–∏—Ç—å(&mut self, –∫–ª—é—á: K, –∑–Ω–∞—á–µ–Ω–∏–µ: V) -> Option<V> {
        if self.–¥–∞–Ω–Ω—ã–µ.len() >= self.–º–∞–∫—Å–∏–º—É–º && !self.–¥–∞–Ω–Ω—ã–µ.contains_key(&–∫–ª—é—á) {
            // –£–¥–∞–ª—è–µ–º –ø–µ—Ä–≤—ã–π —ç–ª–µ–º–µ–Ω—Ç (—É–ø—Ä–æ—â—ë–Ω–Ω–∞—è –ª–æ–≥–∏–∫–∞)
            if let Some(–ø–µ—Ä–≤—ã–π_–∫–ª—é—á) = self.–¥–∞–Ω–Ω—ã–µ.keys().next().cloned() {
                self.–¥–∞–Ω–Ω—ã–µ.remove(&–ø–µ—Ä–≤—ã–π_–∫–ª—é—á);
            }
        }
        self.–¥–∞–Ω–Ω—ã–µ.insert(–∫–ª—é—á, –∑–Ω–∞—á–µ–Ω–∏–µ)
    }
    
    fn –ø–æ–ª—É—á–∏—Ç—å(&self, –∫–ª—é—á: &K) -> Option<&V> {
        self.–¥–∞–Ω–Ω—ã–µ.get(–∫–ª—é—á)
    }
}
```

### Generic —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Å –æ—à–∏–±–∫–æ–π
```rust
#[derive(Debug)]
enum –ú–æ—è–û—à–∏–±–∫–∞ {
    –ù–µ–ù–∞–π–¥–µ–Ω–æ,
    –ù–µ–≤–µ—Ä–Ω—ã–π–í–≤–æ–¥,
}

type –†–µ–∑—É–ª—å—Ç–∞—Ç<T> = Result<T, –ú–æ—è–û—à–∏–±–∫–∞>;

fn –Ω–∞–π—Ç–∏_–∏_—É–¥–≤–æ–∏—Ç—å(—á–∏—Å–ª–∞: &[i32], –∏—Å–∫–æ–º–æ–µ: i32) -> –†–µ–∑—É–ª—å—Ç–∞—Ç<i32> {
    —á–∏—Å–ª–∞
        .iter()
        .find(|&&x| x == –∏—Å–∫–æ–º–æ–µ)
        .map(|&x| x * 2)
        .ok_or(–ú–æ—è–û—à–∏–±–∫–∞::–ù–µ–ù–∞–π–¥–µ–Ω–æ)
}
```

### –ü–∞—Ç—Ç–µ—Ä–Ω Builder —Å generics
```rust
struct –ó–∞–ø—Ä–æ—ÅBuilder<T> {
    url: String,
    –º–µ—Ç–æ–¥: String,
    —Ç–µ–ª–æ: Option<T>,
}

impl<T> –ó–∞–ø—Ä–æ—ÅBuilder<T> {
    fn –Ω–æ–≤—ã–π(url: String) -> Self {
        –ó–∞–ø—Ä–æ—ÅBuilder {
            url,
            –º–µ—Ç–æ–¥: "GET".to_string(),
            —Ç–µ–ª–æ: None,
        }
    }
    
    fn –º–µ—Ç–æ–¥(mut self, –º–µ—Ç–æ–¥: &str) -> Self {
        self.–º–µ—Ç–æ–¥ = –º–µ—Ç–æ–¥.to_string();
        self
    }
    
    fn —Ç–µ–ª–æ(mut self, —Ç–µ–ª–æ: T) -> Self {
        self.—Ç–µ–ª–æ = Some(—Ç–µ–ª–æ);
        self
    }
    
    fn –ø–æ—Å—Ç—Ä–æ–∏—Ç—å(self) -> –ó–∞–ø—Ä–æ—Å<T> {
        –ó–∞–ø—Ä–æ—Å {
            url: self.url,
            –º–µ—Ç–æ–¥: self.–º–µ—Ç–æ–¥,
            —Ç–µ–ª–æ: self.—Ç–µ–ª–æ,
        }
    }
}

struct –ó–∞–ø—Ä–æ—Å<T> {
    url: String,
    –º–µ—Ç–æ–¥: String,
    —Ç–µ–ª–æ: Option<T>,
}
```

## ‚ö° –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å generics

### –ú–æ–Ω–æ–º–æ—Ä—Ñ–∏–∑–∞—Ü–∏—è
```rust
// –≠—Ç–æ—Ç generic –∫–æ–¥
fn –æ–ø—Ü–∏—è<T>(x: T) -> Option<T> {
    Some(x)
}

let —Ü–µ–ª–æ–µ = –æ–ø—Ü–∏—è(5);
let –¥—Ä–æ–±–Ω–æ–µ = –æ–ø—Ü–∏—è(5.0);

// –ö–æ–º–ø–∏–ª—è—Ç–æ—Ä –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –¥–≤–µ –≤–µ—Ä—Å–∏–∏:
// fn –æ–ø—Ü–∏—è_i32(x: i32) -> Option<i32> { Some(x) }
// fn –æ–ø—Ü–∏—è_f64(x: f64) -> Option<f64> { Some(x) }
```

### Zero-cost abstractions
```rust
// Generic –∫–æ–¥ —Ç–∞–∫ –∂–µ –±—ã—Å—Ç—Ä, –∫–∞–∫ –∏ —Å–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π
fn —Å—É–º–º–∞_generic<T>(—Å—Ä–µ–∑: &[T]) -> T
where
    T: std::iter::Sum + Copy,
{
    —Å—Ä–µ–∑.iter().copied().sum()
}

// –ù–µ –º–µ–¥–ª–µ–Ω–Ω–µ–µ —á–µ–º
fn —Å—É–º–º–∞_i32(—Å—Ä–µ–∑: &[i32]) -> i32 {
    —Å—Ä–µ–∑.iter().sum()
}
```

## ‚ö†Ô∏è –ß–∞—Å—Ç—ã–µ –æ—à–∏–±–∫–∏

### –û—à–∏–±–∫–∞ 1: –ó–∞–±—ã—Ç—ã–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è
```rust
// ‚ùå –û–®–ò–ë–ö–ê: T –Ω–µ —Ä–µ–∞–ª–∏–∑—É–µ—Ç Display
fn –ø–æ–∫–∞–∑–∞—Ç—å<T>(–∑–Ω–∞—á–µ–Ω–∏–µ: T) {
    println!("{}", –∑–Ω–∞—á–µ–Ω–∏–µ);
}

// ‚úÖ –ü—Ä–∞–≤–∏–ª—å–Ω–æ
fn –ø–æ–∫–∞–∑–∞—Ç—å<T: std::fmt::Display>(–∑–Ω–∞—á–µ–Ω–∏–µ: T) {
    println!("{}", –∑–Ω–∞—á–µ–Ω–∏–µ);
}
```

### –û—à–∏–±–∫–∞ 2: –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ Self
```rust
struct –ú–æ—è–°—Ç—Ä—É–∫—Ç—É—Ä–∞<T> {
    –∑–Ω–∞—á–µ–Ω–∏–µ: T,
}

impl<T> –ú–æ—è–°—Ç—Ä—É–∫—Ç—É—Ä–∞<T> {
    // ‚ùå –û–®–ò–ë–ö–ê: Self —É–∂–µ –≤–∫–ª—é—á–∞–µ—Ç <T>
    fn –Ω–æ–≤–∞—è(–∑–Ω–∞—á–µ–Ω–∏–µ: T) -> Self<T> {
        –ú–æ—è–°—Ç—Ä—É–∫—Ç—É—Ä–∞ { –∑–Ω–∞—á–µ–Ω–∏–µ }
    }
    
    // ‚úÖ –ü—Ä–∞–≤–∏–ª—å–Ω–æ
    fn –Ω–æ–≤–∞—è_–ø—Ä–∞–≤–∏–ª—å–Ω–æ(–∑–Ω–∞—á–µ–Ω–∏–µ: T) -> Self {
        –ú–æ—è–°—Ç—Ä—É–∫—Ç—É—Ä–∞ { –∑–Ω–∞—á–µ–Ω–∏–µ }
    }
}
```

## üéØ –£–ø—Ä–∞–∂–Ω–µ–Ω–∏—è

1. **–°–æ–∑–¥–∞–π—Ç–µ generic —Å—Ç–µ–∫** —Å –º–µ—Ç–æ–¥–∞–º–∏ push, pop, peek
2. **–†–µ–∞–ª–∏–∑—É–π—Ç–µ generic –æ—á–µ—Ä–µ–¥—å** —Å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω—ã–º —Ä–∞–∑–º–µ—Ä–æ–º
3. **–ù–∞–ø–∏—à–∏—Ç–µ —Ñ—É–Ω–∫—Ü–∏—é** `zip<T, U>(vec1: Vec<T>, vec2: Vec<U>) -> Vec<(T, U)>`
4. **–°–æ–∑–¥–∞–π—Ç–µ generic –¥–µ—Ä–µ–≤–æ** —Å –æ–±—Ö–æ–¥–æ–º –≤ –≥–ª—É–±–∏–Ω—É

## üí° –õ—É—á—à–∏–µ –ø—Ä–∞–∫—Ç–∏–∫–∏

1. **–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –≥–æ–≤–æ—Ä—è—â–∏–µ –∏–º–µ–Ω–∞** –¥–ª—è –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ —Ç–∏–ø–æ–≤ (–Ω–µ —Ç–æ–ª—å–∫–æ T)
2. **–ü—Ä–µ–¥–ø–æ—á–∏—Ç–∞–π—Ç–µ where** –¥–ª—è —Å–ª–æ–∂–Ω—ã—Ö –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π
3. **–î–æ–∫—É–º–µ–Ω—Ç–∏—Ä—É–π—Ç–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è** —Ç—Ä–µ–π—Ç–æ–≤
4. **–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ associated types** –≤–º–µ—Å—Ç–æ generic –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –≥–¥–µ –≤–æ–∑–º–æ–∂–Ω–æ
5. **–ü–æ–º–Ω–∏—Ç–µ –æ –º–æ–Ω–æ–º–æ—Ä—Ñ–∏–∑–∞—Ü–∏–∏** - –∫–∞–∂–¥—ã–π –∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–π —Ç–∏–ø —Å–æ–∑–¥–∞—ë—Ç –∫–æ–ø–∏—é –∫–æ–¥–∞
6. **–¢–µ—Å—Ç–∏—Ä—É–π—Ç–µ —Å —Ä–∞–∑–Ω—ã–º–∏ —Ç–∏–ø–∞–º–∏**

## üìä –®–ø–∞—Ä–≥–∞–ª–∫–∞

```rust
// –§—É–Ω–∫—Ü–∏–∏
fn func<T>(param: T) -> T
fn func<T: Trait>(param: T)
fn func<T, U>(t: T, u: U)

// –°—Ç—Ä—É–∫—Ç—É—Ä—ã
struct S<T> { field: T }
impl<T> S<T> { }
impl S<i32> { }  // –î–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ —Ç–∏–ø–∞

// –ï–Ω—É–º—ã
enum E<T> { Variant(T) }

// –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è
T: Trait
T: Trait + OtherTrait
T: Trait<AssocType = U>
where T: Trait

// Associated types
trait MyTrait {
    type Item;
}
```

## üîó –°–≤—è–∑–∞–Ω–Ω—ã–µ —Ç–µ–º—ã

- [[08_–¢—Ä–µ–π—Ç—ã/00_–ò–Ω–¥–µ–∫—Å|–¢—Ä–µ–π—Ç—ã –∏ trait bounds]]
- [[09_–í—Ä–µ–º–µ–Ω–∞_–∂–∏–∑–Ω–∏/00_–ò–Ω–¥–µ–∫—Å|Generics —Å –≤—Ä–µ–º–µ–Ω–∞–º–∏ –∂–∏–∑–Ω–∏]]
- [[11_–ò—Ç–µ—Ä–∞—Ç–æ—Ä—ã_–∏_–∑–∞–º—ã–∫–∞–Ω–∏—è/00_–ò–Ω–¥–µ–∫—Å|Generic –∑–∞–º—ã–∫–∞–Ω–∏—è]]
- [[06_–ö–æ–ª–ª–µ–∫—Ü–∏–∏/00_–ò–Ω–¥–µ–∫—Å|Generic –∫–æ–ª–ª–µ–∫—Ü–∏–∏]]

---
#rust #generics #–æ–±–æ–±—â–µ–Ω–∏—è #—Ç–∏–ø—ã #–ø–∞—Ä–∞–º–µ—Ç—Ä–∏—á–µ—Å–∫–∏–π_–ø–æ–ª–∏–º–æ—Ä—Ñ–∏–∑–º
