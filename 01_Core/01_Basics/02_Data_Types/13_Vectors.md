# üì¶ Vectors - –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–µ –º–∞—Å—Å–∏–≤—ã

## üìã –û–±–∑–æ—Ä Vec<T>

`Vec<T>` - —ç—Ç–æ –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–π –º–∞—Å—Å–∏–≤, –∫–æ—Ç–æ—Ä—ã–π –º–æ–∂–µ—Ç –∏–∑–º–µ–Ω—è—Ç—å —Å–≤–æ–π —Ä–∞–∑–º–µ—Ä. –≠—Ç–æ –æ–¥–Ω–∞ –∏–∑ —Å–∞–º—ã—Ö –∏—Å–ø–æ–ª—å–∑—É–µ–º—ã—Ö –∫–æ–ª–ª–µ–∫—Ü–∏–π –≤ Rust.

```mermaid
graph TD
    A[Vec Properties] --> B[Heap Allocated]
    A --> C[Growable]
    A --> D[Contiguous Memory]
    A --> E[Generic over T]
    
    B --> B1[Automatic memory management]
    C --> C1[Dynamic size]
    D --> D1[Cache-friendly]
    E --> E1[Type-safe]
```

### –•–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏ Vec
- **–†–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏–µ**: Heap
- **–†–∞–∑–º–µ—Ä**: –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–π
- **–ü–∞–º—è—Ç—å**: –ù–µ–ø—Ä–µ—Ä—ã–≤–Ω–∞—è
- **–í–ª–∞–¥–µ–Ω–∏–µ**: –í–ª–∞–¥–µ–µ—Ç —ç–ª–µ–º–µ–Ω—Ç–∞–º–∏
- **–ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å**: O(1) –¥–æ—Å—Ç—É–ø –ø–æ –∏–Ω–¥–µ–∫—Å—É, O(1) push/pop –≤ –∫–æ–Ω—Ü–µ

## üíª –°–æ–∑–¥–∞–Ω–∏–µ –≤–µ–∫—Ç–æ—Ä–æ–≤

### –†–∞–∑–ª–∏—á–Ω—ã–µ —Å–ø–æ—Å–æ–±—ã —Å–æ–∑–¥–∞–Ω–∏—è
```rust
// –ü—É—Å—Ç–æ–π –≤–µ–∫—Ç–æ—Ä
let v1: Vec<i32> = Vec::new();
let v2 = Vec::<i32>::new();
let mut v3: Vec<i32> = vec![];

// –° –Ω–∞—á–∞–ª—å–Ω—ã–º–∏ —ç–ª–µ–º–µ–Ω—Ç–∞–º–∏
let v4 = vec![1, 2, 3, 4, 5];
let v5 = vec![0; 10];              // 10 —ç–ª–µ–º–µ–Ω—Ç–æ–≤ —Å–æ –∑–Ω–∞—á–µ–Ω–∏–µ–º 0

// –° –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω—ã–º –≤—ã–¥–µ–ª–µ–Ω–∏–µ–º capacity
let mut v6 = Vec::with_capacity(100);

// –ò–∑ –∏—Ç–µ—Ä–∞—Ç–æ—Ä–∞
let v7: Vec<i32> = (0..10).collect();
let v8: Vec<_> = [1, 2, 3].iter().cloned().collect();

// –ò–∑ —Å—Ä–µ–∑–∞
let slice = &[1, 2, 3];
let v9 = slice.to_vec();
let v10 = Vec::from(slice);
```

### –ú–∞–∫—Ä–æ—Å vec!
```rust
// –ü—Ä–æ—Å—Ç–æ–µ —Å–æ–∑–¥–∞–Ω–∏–µ
let v = vec![1, 2, 3];

// –° –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏–µ–º
let v = vec![0; 5];  // [0, 0, 0, 0, 0]

// –° –≤—ã—á–∏—Å–ª–µ–Ω–∏—è–º–∏
let v = vec![1 + 1, 2 * 2, 3 * 3];  // [2, 4, 9]

// –ú–Ω–æ–≥–æ—Å—Ç—Ä–æ—á–Ω—ã–π
let v = vec![
    "apple",
    "banana",
    "cherry",
];
```

## üîß –û—Å–Ω–æ–≤–Ω—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏

### –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç–æ–≤
```rust
let mut v = vec![1, 2, 3];

// –í –∫–æ–Ω–µ—Ü
v.push(4);                          // [1, 2, 3, 4]
v.append(&mut vec![5, 6]);         // [1, 2, 3, 4, 5, 6]
v.extend([7, 8].iter().cloned());  // [1, 2, 3, 4, 5, 6, 7, 8]

// –í –ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω—É—é –ø–æ–∑–∏—Ü–∏—é
v.insert(0, 0);                    // [0, 1, 2, 3, 4, 5, 6, 7, 8]
v.splice(2..4, vec![10, 11]);      // –ó–∞–º–µ–Ω–∏—Ç—å –¥–∏–∞–ø–∞–∑–æ–Ω

// Resize
v.resize(5, 0);                    // –ò–∑–º–µ–Ω–∏—Ç—å —Ä–∞–∑–º–µ—Ä, –∑–∞–ø–æ–ª–Ω–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ–º
v.resize_with(10, Default::default); // –° —Ñ—É–Ω–∫—Ü–∏–µ–π-–≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–æ–º
```

### –£–¥–∞–ª–µ–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç–æ–≤
```rust
let mut v = vec![1, 2, 3, 4, 5];

// –ò–∑ –∫–æ–Ω—Ü–∞
let last = v.pop();                // Some(5), v = [1, 2, 3, 4]

// –ü–æ –∏–Ω–¥–µ–∫—Å—É
let removed = v.remove(1);         // 2, v = [1, 3, 4]
let swapped = v.swap_remove(0);    // 1, v = [4, 3] (–±—ã—Å—Ç—Ä–µ–µ remove)

// –û—á–∏—Å—Ç–∫–∞
v.clear();                         // v = []
v.truncate(2);                     // –û–±—Ä–µ–∑–∞—Ç—å –¥–æ –¥–ª–∏–Ω—ã

// –£–¥–∞–ª–µ–Ω–∏–µ –ø–æ —É—Å–ª–æ–≤–∏—é
v.retain(|&x| x % 2 == 0);        // –û—Å—Ç–∞–≤–∏—Ç—å —Ç–æ–ª—å–∫–æ —á–µ—Ç–Ω—ã–µ
v.dedup();                         // –£–¥–∞–ª–∏—Ç—å –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω—ã–µ –¥—É–±–ª–∏–∫–∞—Ç—ã
```

### –î–æ—Å—Ç—É–ø –∫ —ç–ª–µ–º–µ–Ω—Ç–∞–º
```rust
let v = vec![1, 2, 3, 4, 5];

// –ü–æ –∏–Ω–¥–µ–∫—Å—É
let third = v[2];                  // 3 (–º–æ–∂–µ—Ç –ø–∞–Ω–∏–∫–æ–≤–∞—Ç—å)
let safe = v.get(2);              // Some(3) (–±–µ–∑–æ–ø–∞—Å–Ω–æ)

// –ü–µ—Ä–≤—ã–π –∏ –ø–æ—Å–ª–µ–¥–Ω–∏–π
let first = v.first();             // Some(1)
let last = v.last();               // Some(5)

// –°—Ä–µ–∑—ã
let slice = &v[1..3];              // [2, 3]
let all = &v[..];                  // –í–µ—Å—å –≤–µ–∫—Ç–æ—Ä –∫–∞–∫ —Å—Ä–µ–∑

// –ò–∑–º–µ–Ω—è–µ–º—ã–π –¥–æ—Å—Ç—É–ø
let mut v = vec![1, 2, 3];
v[0] = 10;
if let Some(elem) = v.get_mut(1) {
    *elem = 20;
}
```

## üîÑ –ò—Ç–µ—Ä–∞—Ü–∏—è

### –†–∞–∑–ª–∏—á–Ω—ã–µ –≤–∏–¥—ã –∏—Ç–µ—Ä–∞—Ç–æ—Ä–æ–≤
```rust
let mut v = vec![1, 2, 3, 4, 5];

// –ù–µ–∏–∑–º–µ–Ω—è–µ–º–∞—è –∏—Ç–µ—Ä–∞—Ü–∏—è
for item in &v {
    println!("{}", item);          // –ó–∞–∏–º—Å—Ç–≤–æ–≤–∞–Ω–∏–µ
}

// –ò–∑–º–µ–Ω—è–µ–º–∞—è –∏—Ç–µ—Ä–∞—Ü–∏—è
for item in &mut v {
    *item *= 2;                    // –ò–∑–º–µ–Ω–µ–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç–æ–≤
}

// –ü–æ—Ç—Ä–µ–±–ª—è—é—â–∞—è –∏—Ç–µ—Ä–∞—Ü–∏—è
for item in v {
    println!("{}", item);          // v –±–æ–ª—å—à–µ –Ω–µ –¥–æ—Å—Ç—É–ø–µ–Ω
}

// –ò—Ç–µ—Ä–∞—Ç–æ—Ä—ã
let iter = v.iter();               // Iterator<Item = &T>
let iter_mut = v.iter_mut();       // Iterator<Item = &mut T>
let into_iter = v.into_iter();     // Iterator<Item = T>

// –° –∏–Ω–¥–µ–∫—Å–∞–º–∏
for (index, value) in v.iter().enumerate() {
    println!("{}: {}", index, value);
}

// Chunks
for chunk in v.chunks(2) {
    println!("{:?}", chunk);       // [1, 2], [3, 4], [5]
}

// Windows
for window in v.windows(3) {
    println!("{:?}", window);      // [1, 2, 3], [2, 3, 4], [3, 4, 5]
}
```

## üé® –ú–µ—Ç–æ–¥—ã –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è

### Map, Filter, Fold
```rust
let v = vec![1, 2, 3, 4, 5];

// Map - –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ
let doubled: Vec<i32> = v.iter().map(|x| x * 2).collect();

// Filter - —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—è
let evens: Vec<i32> = v.iter()
    .filter(|&&x| x % 2 == 0)
    .cloned()
    .collect();

// Fold - —Å–≤–µ—Ä—Ç–∫–∞
let sum = v.iter().fold(0, |acc, x| acc + x);

// –ö–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ
let result: Vec<i32> = v.iter()
    .map(|x| x * 2)
    .filter(|x| x > &5)
    .take(3)
    .collect();

// Flat map
let nested = vec![vec![1, 2], vec![3, 4]];
let flat: Vec<i32> = nested.into_iter()
    .flat_map(|x| x)
    .collect();
```

### –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –∏ –ø–æ–∏—Å–∫
```rust
let mut v = vec![3, 1, 4, 1, 5, 9, 2, 6];

// –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞
v.sort();                          // –ü–æ –≤–æ–∑—Ä–∞—Å—Ç–∞–Ω–∏—é
v.sort_by(|a, b| b.cmp(a));       // –ü–æ —É–±—ã–≤–∞–Ω–∏—é
v.sort_by_key(|x| -x);             // –ü–æ –∫–ª—é—á—É

// –î–ª—è float –∏–ª–∏ –Ω–µ—Å—Ç–∞–±–∏–ª—å–Ω–∞—è
v.sort_unstable();                 // –ë—ã—Å—Ç—Ä–µ–µ, –Ω–æ –Ω–µ —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç –ø–æ—Ä—è–¥–æ–∫ —Ä–∞–≤–Ω—ã—Ö

// –ü–æ–∏—Å–∫
let pos = v.iter().position(|&x| x == 4);  // –ò–Ω–¥–µ–∫—Å –ø–µ—Ä–≤–æ–≥–æ
let rpos = v.iter().rposition(|&x| x == 1); // –ò–Ω–¥–µ–∫—Å –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ
let found = v.binary_search(&5);           // –¢—Ä–µ–±—É–µ—Ç –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π

// Min/Max
let min = v.iter().min();
let max = v.iter().max();
let minmax = v.iter().minmax();   // –¢—Ä–µ–±—É–µ—Ç itertools
```

## üìä Capacity –∏ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å

### –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ capacity
```rust
let mut v = Vec::with_capacity(10);

println!("Length: {}", v.len());       // 0
println!("Capacity: {}", v.capacity()); // 10

// –î–æ–±–∞–≤–ª—è–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã
for i in 0..5 {
    v.push(i);
}

println!("Length: {}", v.len());       // 5
println!("Capacity: {}", v.capacity()); // 10

// –†–µ–∑–µ—Ä–≤–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–≥–æ –º–µ—Å—Ç–∞
v.reserve(20);                         // –ì–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç –º–∏–Ω–∏–º—É–º 20 –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã—Ö
v.reserve_exact(30);                   // –¢–æ—á–Ω–æ 30 –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã—Ö

// –û—Å–≤–æ–±–æ–∂–¥–µ–Ω–∏–µ –Ω–µ–∏—Å–ø–æ–ª—å–∑—É–µ–º–æ–π –ø–∞–º—è—Ç–∏
v.shrink_to_fit();                    // capacity = len
v.shrink_to(8);                       // –£–º–µ–Ω—å—à–∏—Ç—å –¥–æ —É–∫–∞–∑–∞–Ω–Ω–æ–≥–æ
```

### –°—Ç—Ä–∞—Ç–µ–≥–∏—è —Ä–æ—Å—Ç–∞
```rust
// Vec —É–¥–≤–∞–∏–≤–∞–µ—Ç capacity –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏
let mut v = Vec::new();
let mut prev_cap = v.capacity();

for i in 0..100 {
    v.push(i);
    let new_cap = v.capacity();
    if new_cap != prev_cap {
        println!("Capacity changed: {} -> {}", prev_cap, new_cap);
        prev_cap = new_cap;
    }
}
// Output: 0 -> 4 -> 8 -> 16 -> 32 -> 64 -> 128
```

## ‚ö†Ô∏è –ß–∞—Å—Ç—ã–µ –ø—Ä–æ–±–ª–µ–º—ã –∏ —Ä–µ—à–µ–Ω–∏—è

### –ü—Ä–æ–±–ª–µ–º–∞ 1: –ü–∞–Ω–∏–∫–∞ –ø—Ä–∏ –∏–Ω–¥–µ–∫—Å–∞—Ü–∏–∏
```rust
let v = vec![1, 2, 3];

// ‚ùå –ú–æ–∂–µ—Ç –ø–∞–Ω–∏–∫–æ–≤–∞—Ç—å
let item = v[10];  // panic!

// ‚úÖ –ë–µ–∑–æ–ø–∞—Å–Ω—ã–π –¥–æ—Å—Ç—É–ø
if let Some(item) = v.get(10) {
    println!("{}", item);
} else {
    println!("Index out of bounds");
}
```

### –ü—Ä–æ–±–ª–µ–º–∞ 2: –ò–Ω–≤–∞–ª–∏–¥–∞—Ü–∏—è —Å—Å—ã–ª–æ–∫
```rust
let mut v = vec![1, 2, 3];

// ‚ùå –°—Å—ã–ª–∫–∞ —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è –Ω–µ–≤–∞–ª–∏–¥–Ω–æ–π
let first = &v[0];
v.push(4);  // –ú–æ–∂–µ—Ç –ø–µ—Ä–µ–≤—ã–¥–µ–ª–∏—Ç—å –ø–∞–º—è—Ç—å
// println!("{}", first); // –û–®–ò–ë–ö–ê: borrow checker

// ‚úÖ –ü—Ä–∞–≤–∏–ª—å–Ω—ã–π –ø–æ—Ä—è–¥–æ–∫
v.push(4);
let first = &v[0];
println!("{}", first);
```

### –ü—Ä–æ–±–ª–µ–º–∞ 3: –ù–µ—ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ–µ –≤—ã–¥–µ–ª–µ–Ω–∏–µ –ø–∞–º—è—Ç–∏
```rust
// ‚ùå –ú–Ω–æ–≥–æ –ø–µ—Ä–µ–≤—ã–¥–µ–ª–µ–Ω–∏–π
let mut v = Vec::new();
for i in 0..1000 {
    v.push(i);  // –ú–Ω–æ–≥–æ —Ä–µ–∞–ª–ª–æ–∫–∞—Ü–∏–π
}

// ‚úÖ –ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ–µ –≤—ã–¥–µ–ª–µ–Ω–∏–µ
let mut v = Vec::with_capacity(1000);
for i in 0..1000 {
    v.push(i);  // –ë–µ–∑ —Ä–µ–∞–ª–ª–æ–∫–∞—Ü–∏–π
}
```

## üéØ Best Practices

### 1. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ with_capacity –∫–æ–≥–¥–∞ –∑–Ω–∞–µ—Ç–µ —Ä–∞–∑–º–µ—Ä
```rust
// –ü–ª–æ—Ö–æ
let mut v = Vec::new();
for i in 0..known_size {
    v.push(compute(i));
}

// –•–æ—Ä–æ—à–æ
let mut v = Vec::with_capacity(known_size);
for i in 0..known_size {
    v.push(compute(i));
}
```

### 2. –ü—Ä–µ–¥–ø–æ—á–∏—Ç–∞–π—Ç–µ –∏—Ç–µ—Ä–∞—Ç–æ—Ä—ã —Ü–∏–∫–ª–∞–º
```rust
// –ú–µ–Ω–µ–µ –∏–¥–∏–æ–º–∞—Ç–∏—á–Ω–æ
let mut result = Vec::new();
for x in &input {
    if x > &0 {
        result.push(x * 2);
    }
}

// –ò–¥–∏–æ–º–∞—Ç–∏—á–Ω–æ
let result: Vec<_> = input.iter()
    .filter(|&&x| x > 0)
    .map(|x| x * 2)
    .collect();
```

### 3. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –º–µ—Ç–æ–¥ —É–¥–∞–ª–µ–Ω–∏—è
```rust
// remove - O(n), —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç –ø–æ—Ä—è–¥–æ–∫
v.remove(index);

// swap_remove - O(1), –Ω–µ —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç –ø–æ—Ä—è–¥–æ–∫
v.swap_remove(index);

// –í—ã–±–∏—Ä–∞–π—Ç–µ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç—Ä–µ–±–æ–≤–∞–Ω–∏–π
```

## üéØ –§–ª–µ—à-–∫–∞—Ä—Ç–æ—á–∫–∏

#flashcard 
Q: –ì–¥–µ Vec<T> —Ö—Ä–∞–Ω–∏—Ç —Å–≤–æ–∏ –¥–∞–Ω–Ω—ã–µ?
A: –í heap, –≤ –Ω–µ–ø—Ä–µ—Ä—ã–≤–Ω–æ–π –æ–±–ª–∞—Å—Ç–∏ –ø–∞–º—è—Ç–∏
<!--SR:!2024-03-07,4,270-->

#flashcard 
Q: –ö–∞–∫–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å –¥–æ—Å—Ç—É–ø–∞ –∫ —ç–ª–µ–º–µ–Ω—Ç—É Vec –ø–æ –∏–Ω–¥–µ–∫—Å—É?
A: O(1) - –∫–æ–Ω—Å—Ç–∞–Ω—Ç–Ω–∞—è
<!--SR:!2024-03-08,5,280-->

#flashcard 
Q: –í —á–µ–º —Ä–∞–∑–Ω–∏—Ü–∞ –º–µ–∂–¥—É len() –∏ capacity()?
A: len() - –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤, capacity() - –≤—ã–¥–µ–ª–µ–Ω–Ω–∞—è –ø–∞–º—è—Ç—å
<!--SR:!2024-03-09,3,250-->

## üîó –°–≤—è–∑–∞–Ω–Ω—ã–µ —Ç–µ–º—ã

- [[01_Core/01_Basics/02_Data_Types/07_Arrays|Arrays]] - —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏–µ –º–∞—Å—Å–∏–≤—ã
- [[01_Core/01_Basics/02_Data_Types/08_Slices|Slices]] - —Å—Ä–µ–∑—ã
- [[01_Core/01_Basics/02_Data_Types/14_HashMap|HashMap]] - –∞—Å—Å–æ—Ü–∏–∞—Ç–∏–≤–Ω—ã–µ –º–∞—Å—Å–∏–≤—ã
- [[01_Core/02_Ownership/01_Ownership_Rules|Ownership]] - –≤–ª–∞–¥–µ–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç–∞–º–∏

---
#rust #vector #vec #collections #dynamic-array
