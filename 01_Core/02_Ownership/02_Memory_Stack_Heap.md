# üìö Memory: Stack vs Heap

## üéØ –û—Å–Ω–æ–≤–Ω—ã–µ –∫–æ–Ω—Ü–µ–ø—Ü–∏–∏

–í Rust –ø–æ–Ω–∏–º–∞–Ω–∏–µ Stack –∏ Heap –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏ –≤–∞–∂–Ω–æ –¥–ª—è –ø–æ–Ω–∏–º–∞–Ω–∏—è ownership.

### Stack (–°—Ç–µ–∫)
- **LIFO** (Last In, First Out)
- **–ë—ã—Å—Ç—Ä—ã–π** –¥–æ—Å—Ç—É–ø
- **–§–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ä–∞–∑–º–µ—Ä** –¥–∞–Ω–Ω—ã—Ö
- **–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ** —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–∞–º—è—Ç—å—é
- –•—Ä–∞–Ω–∏—Ç: –ø—Ä–∏–º–∏—Ç–∏–≤—ã, —É–∫–∞–∑–∞—Ç–µ–ª–∏, —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã

### Heap (–ö—É—á–∞)
- **–ü—Ä–æ–∏–∑–≤–æ–ª—å–Ω—ã–π** –¥–æ—Å—Ç—É–ø
- **–ú–µ–¥–ª–µ–Ω–Ω–µ–µ** —Å—Ç–µ–∫–∞
- **–î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–π —Ä–∞–∑–º–µ—Ä** –¥–∞–Ω–Ω—ã—Ö
- **–†—É—á–Ω–æ–µ** —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ (—á–µ—Ä–µ–∑ ownership)
- –•—Ä–∞–Ω–∏—Ç: String, Vec, Box –∏ –¥—Ä—É–≥–∏–µ –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–µ —Ç–∏–ø—ã

## üìä –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –ø–∞–º—è—Ç–∏

```
STACK                           HEAP
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ main()      ‚îÇ                ‚îÇ                 ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§                ‚îÇ  String data    ‚îÇ
‚îÇ x = 5       ‚îÇ                ‚îÇ  "Hello"        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§      ptr ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ s = String  ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ           ‚îÇ                 ‚îÇ
‚îÇ (ptr,len,cap)                ‚îÇ  Vec data       ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§      ptr ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>  [1,2,3,4,5]    ‚îÇ
‚îÇ v = Vec     ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ           ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ (ptr,len,cap)                ‚îÇ                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## üíæ –ß—Ç–æ —Ö—Ä–∞–Ω–∏—Ç—Å—è –≥–¥–µ?

### –ù–∞ —Å—Ç–µ–∫–µ
```rust
// –ü—Ä–∏–º–∏—Ç–∏–≤–Ω—ã–µ —Ç–∏–ø—ã - –∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ä–∞–∑–º–µ—Ä
let x: i32 = 5;              // 4 –±–∞–π—Ç–∞ –Ω–∞ —Å—Ç–µ–∫–µ
let y: f64 = 3.14;           // 8 –±–∞–π—Ç –Ω–∞ —Å—Ç–µ–∫–µ
let flag: bool = true;       // 1 –±–∞–π—Ç –Ω–∞ —Å—Ç–µ–∫–µ
let c: char = 'z';           // 4 –±–∞–π—Ç–∞ –Ω–∞ —Å—Ç–µ–∫–µ

// –ú–∞—Å—Å–∏–≤—ã —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ —Ä–∞–∑–º–µ—Ä–∞
let arr: [i32; 5] = [1, 2, 3, 4, 5]; // 20 –±–∞–π—Ç –Ω–∞ —Å—Ç–µ–∫–µ

// –ö–æ—Ä—Ç–µ–∂–∏
let tup: (i32, f64) = (500, 6.4);    // 12 –±–∞–π—Ç –Ω–∞ —Å—Ç–µ–∫–µ

// –°—Ç—Ä—É–∫—Ç—É—Ä—ã —Å —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–º —Ä–∞–∑–º–µ—Ä–æ–º
struct Point {
    x: i32,
    y: i32,
}
let p = Point { x: 10, y: 20 };      // 8 –±–∞–π—Ç –Ω–∞ —Å—Ç–µ–∫–µ
```

### –ù–∞ –∫—É—á–µ
```rust
// String - –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–π —Ä–∞–∑–º–µ—Ä
let s = String::from("hello");       // –¥–∞–Ω–Ω—ã–µ –Ω–∞ –∫—É—á–µ, –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ –Ω–∞ —Å—Ç–µ–∫–µ

// Vec - –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–π –º–∞—Å—Å–∏–≤
let v = vec![1, 2, 3, 4, 5];        // –¥–∞–Ω–Ω—ã–µ –Ω–∞ –∫—É—á–µ, –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ –Ω–∞ —Å—Ç–µ–∫–µ

// Box - —è–≤–Ω–æ–µ —Ä–∞–∑–º–µ—â–µ–Ω–∏–µ –Ω–∞ –∫—É—á–µ
let b = Box::new(5);                 // 5 –Ω–∞ –∫—É—á–µ, —É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ —Å—Ç–µ–∫–µ

// HashMap –∏ –¥—Ä—É–≥–∏–µ –∫–æ–ª–ª–µ–∫—Ü–∏–∏
use std::collections::HashMap;
let mut map = HashMap::new();        // –¥–∞–Ω–Ω—ã–µ –Ω–∞ –∫—É—á–µ
map.insert("key", "value");
```

## üîÑ Copy vs Move —Å–µ–º–∞–Ω—Ç–∏–∫–∞

### Copy —Ç–∏–ø—ã (—Å—Ç–µ–∫)
```rust
let x = 5;
let y = x;  // –ö–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ
println!("x = {}, y = {}", x, y); // –û–±–∞ –≤–∞–ª–∏–¥–Ω—ã

// –í—Å–µ —Ü–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω—ã–µ —Ç–∏–ø—ã
let a: i32 = 42;
let b = a;  // Copy

// –ë—É–ª–µ–≤—ã –∑–Ω–∞—á–µ–Ω–∏—è
let flag1 = true;
let flag2 = flag1;  // Copy

// –°–∏–º–≤–æ–ª—ã
let c1 = 'A';
let c2 = c1;  // Copy

// –ö–æ—Ä—Ç–µ–∂–∏ –∏–∑ Copy —Ç–∏–ø–æ–≤
let tup1 = (1, 2.0, true);
let tup2 = tup1;  // Copy
```

### Move —Ç–∏–ø—ã (–∫—É—á–∞)
```rust
let s1 = String::from("hello");
let s2 = s1;  // Move - s1 –±–æ–ª—å—à–µ –Ω–µ –≤–∞–ª–∏–¥–Ω–∞
// println!("{}", s1); // –û–®–ò–ë–ö–ê!

let v1 = vec![1, 2, 3];
let v2 = v1;  // Move - v1 –±–æ–ª—å—à–µ –Ω–µ –≤–∞–ª–∏–¥–Ω–∞

// –î–ª—è –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è –∏—Å–ø–æ–ª—å–∑—É–µ–º clone()
let s3 = String::from("world");
let s4 = s3.clone();  // –ì–ª—É–±–æ–∫–æ–µ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ
println!("s3 = {}, s4 = {}", s3, s4); // –û–±–∞ –≤–∞–ª–∏–¥–Ω—ã
```

## üìà –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å

### –°—Ä–∞–≤–Ω–µ–Ω–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–π
| –û–ø–µ—Ä–∞—Ü–∏—è | Stack | Heap |
|----------|-------|------|
| –í—ã–¥–µ–ª–µ–Ω–∏–µ | O(1) - –ø—Ä–æ—Å—Ç–æ —Å–¥–≤–∏–≥ —É–∫–∞–∑–∞—Ç–µ–ª—è | O(n) - –ø–æ–∏—Å–∫ —Å–≤–æ–±–æ–¥–Ω–æ–≥–æ –º–µ—Å—Ç–∞ |
| –û—Å–≤–æ–±–æ–∂–¥–µ–Ω–∏–µ | O(1) - –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ | O(n) - –º–æ–∂–µ—Ç —Ç—Ä–µ–±–æ–≤–∞—Ç—å –¥–µ—Ñ—Ä–∞–≥–º–µ–Ω—Ç–∞—Ü–∏–∏ |
| –î–æ—Å—Ç—É–ø | –ü—Ä—è–º–æ–π, –±—ã—Å—Ç—Ä—ã–π | –ß–µ—Ä–µ–∑ —É–∫–∞–∑–∞—Ç–µ–ª—å, –º–µ–¥–ª–µ–Ω–Ω–µ–µ |
| –ö—ç—à-—ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å | –í—ã—Å–æ–∫–∞—è | –ù–∏–∑–∫–∞—è |

### –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
```rust
// ‚ùå –ù–µ—ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ - –º–Ω–æ–≥–æ –∞–ª–ª–æ–∫–∞—Ü–∏–π
fn inefficient() {
    for i in 0..1000 {
        let s = String::from("temp"); // –ê–ª–ª–æ–∫–∞—Ü–∏—è –Ω–∞ –∫–∞–∂–¥–æ–π –∏—Ç–µ—Ä–∞—Ü–∏–∏
        // –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ s
    }
}

// ‚úÖ –≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ - –ø–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
fn efficient() {
    let mut s = String::with_capacity(100); // –û–¥–Ω–∞ –∞–ª–ª–æ–∫–∞—Ü–∏—è
    for i in 0..1000 {
        s.clear();
        s.push_str("temp");
        // –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ s
    }
}
```

## üéØ Small String Optimization (SSO)

–ù–µ–∫–æ—Ç–æ—Ä—ã–µ —Ç–∏–ø—ã –∏—Å–ø–æ–ª—å–∑—É—é—Ç –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –º–∞–ª–µ–Ω—å–∫–∏—Ö –∑–Ω–∞—á–µ–Ω–∏–π –Ω–∞ —Å—Ç–µ–∫–µ:

```rust
// SmallVec - –≤–µ–∫—Ç–æ—Ä —Å –±—É—Ñ–µ—Ä–æ–º –Ω–∞ —Å—Ç–µ–∫–µ
use smallvec::SmallVec;
let small: SmallVec<[i32; 4]> = smallvec![1, 2, 3]; // –ù–∞ —Å—Ç–µ–∫–µ
let large: SmallVec<[i32; 4]> = smallvec![1, 2, 3, 4, 5]; // –ü–µ—Ä–µ—Ö–æ–¥–∏—Ç –Ω–∞ –∫—É—á—É

// Cow - Copy on Write
use std::borrow::Cow;
fn process(data: Cow<str>) {
    // –ò–∑–±–µ–≥–∞–µ–º –∞–ª–ª–æ–∫–∞—Ü–∏–∏ –µ—Å–ª–∏ –Ω–µ –Ω—É–∂–Ω–æ –∏–∑–º–µ–Ω–µ–Ω–∏–µ
}
```

## üîó –°–≤—è–∑–∞–Ω–Ω—ã–µ –∫–æ–Ω—Ü–µ–ø—Ü–∏–∏

- [[01_Core/02_Ownership/01_Ownership_Rules|Ownership Rules]] - –ø—Ä–∞–≤–∏–ª–∞ –≤–ª–∞–¥–µ–Ω–∏—è
- [[01_Core/02_Ownership/03_Move_Semantics|Move Semantics]] - –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö
- [[01_Core/02_Ownership/04_Copy_Clone|Copy –∏ Clone]] - –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ
- [[02_Advanced/03_Smart_Pointers/01_Box|Box]] - —è–≤–Ω–æ–µ —Ä–∞–∑–º–µ—â–µ–Ω–∏–µ –Ω–∞ –∫—É—á–µ

## üíª –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ –ø—Ä–∏–º–µ—Ä—ã

### –ü—Ä–∏–º–µ—Ä 1: –ê–Ω–∞–ª–∏–∑ —Ä–∞–∑–º–µ—â–µ–Ω–∏—è
```rust
use std::mem;

fn analyze_memory() {
    // Stack
    let x = 42;
    println!("Size of i32: {} bytes", mem::size_of_val(&x));
    println!("Address of x: {:p}", &x);
    
    // Heap
    let s = String::from("Hello, Rust!");
    println!("Size of String struct: {} bytes", mem::size_of_val(&s));
    println!("String capacity: {} bytes", s.capacity());
    println!("String pointer: {:p}", s.as_ptr());
    
    // Box
    let b = Box::new(100);
    println!("Size of Box<i32>: {} bytes", mem::size_of_val(&b));
    println!("Box points to: {:p}", b.as_ref());
}
```

### –ü—Ä–∏–º–µ—Ä 2: –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –∞–ª–ª–æ–∫–∞—Ü–∏–π
```rust
fn string_builder() -> String {
    // –ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ–µ –≤—ã–¥–µ–ª–µ–Ω–∏–µ –ø–∞–º—è—Ç–∏
    let mut result = String::with_capacity(100);
    
    for i in 0..10 {
        result.push_str(&format!("Item {}, ", i));
    }
    
    result
}

fn vector_operations() {
    // –†–µ–∑–µ—Ä–≤–∏—Ä–æ–≤–∞–Ω–∏–µ –º–µ—Å—Ç–∞
    let mut vec = Vec::with_capacity(1000);
    
    for i in 0..1000 {
        vec.push(i); // –ë–µ–∑ —Ä–µ–∞–ª–ª–æ–∫–∞—Ü–∏–π
    }
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –ø–∞–º—è—Ç–∏
    println!("Length: {}, Capacity: {}", vec.len(), vec.capacity());
}
```

### –ü—Ä–∏–º–µ—Ä 3: –ü—Ä–æ—Ñ–∏–ª–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–∞–º—è—Ç–∏
```rust
#[derive(Debug)]
struct MemoryStats {
    stack_size: usize,
    heap_allocations: usize,
}

fn measure_memory<T>(value: &T) -> MemoryStats {
    MemoryStats {
        stack_size: std::mem::size_of_val(value),
        heap_allocations: 0, // –¢—Ä–µ–±—É–µ—Ç —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã—Ö –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤
    }
}
```

## üéØ –§–ª–µ—à-–∫–∞—Ä—Ç–æ—á–∫–∏

#flashcard 
Q: –ì–¥–µ —Ö—Ä–∞–Ω–∏—Ç—Å—è String –≤ –ø–∞–º—è—Ç–∏?
A: –ú–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ (ptr, len, capacity) –Ω–∞ —Å—Ç–µ–∫–µ, —Å–∞–º–∏ –¥–∞–Ω–Ω—ã–µ –Ω–∞ –∫—É—á–µ
<!--SR:!2024-01-28,5,280-->

#flashcard 
Q: –ö–∞–∫–∏–µ —Ç–∏–ø—ã —Ä–µ–∞–ª–∏–∑—É—é—Ç Copy trait?
A: –í—Å–µ –ø—Ä–∏–º–∏—Ç–∏–≤–Ω—ã–µ —Ç–∏–ø—ã (—á–∏—Å–ª–∞, bool, char) –∏ –∫–æ—Ä—Ç–µ–∂–∏ –∏–∑ Copy —Ç–∏–ø–æ–≤
<!--SR:!2024-01-29,4,265-->

#flashcard 
Q: –ß—Ç–æ –±—ã—Å—Ç—Ä–µ–µ - –≤—ã–¥–µ–ª–µ–Ω–∏–µ –Ω–∞ —Å—Ç–µ–∫–µ –∏–ª–∏ –∫—É—á–µ?
A: –°—Ç–µ–∫ –∑–Ω–∞—á–∏—Ç–µ–ª—å–Ω–æ –±—ã—Å—Ç—Ä–µ–µ (O(1) vs O(n))
<!--SR:!2024-01-30,3,250-->

## ‚ö†Ô∏è –ß–∞—Å—Ç—ã–µ –ø—Ä–æ–±–ª–µ–º—ã

### –ü—Ä–æ–±–ª–µ–º–∞ 1: Stack Overflow
```rust
// ‚ùå –°–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π –º–∞—Å—Å–∏–≤ –Ω–∞ —Å—Ç–µ–∫–µ
fn stack_overflow() {
    let huge_array = [0u8; 10_000_000]; // Stack overflow!
}

// ‚úÖ –ò—Å–ø–æ–ª—å–∑—É–µ–º –∫—É—á—É
fn use_heap() {
    let huge_vec = vec![0u8; 10_000_000]; // –ù–∞ –∫—É—á–µ
    // –∏–ª–∏
    let huge_box = Box::new([0u8; 10_000_000]); // –ù–∞ –∫—É—á–µ
}
```

### –ü—Ä–æ–±–ª–µ–º–∞ 2: –§—Ä–∞–≥–º–µ–Ω—Ç–∞—Ü–∏—è –ø–∞–º—è—Ç–∏
```rust
// ‚ùå –ú–Ω–æ–≥–æ –º–µ–ª–∫–∏—Ö –∞–ª–ª–æ–∫–∞—Ü–∏–π
fn fragmented() {
    let mut strings = Vec::new();
    for i in 0..10000 {
        strings.push(format!("{}", i)); // –ö–∞–∂–¥–∞—è —Å—Ç—Ä–æ–∫–∞ - –æ—Ç–¥–µ–ª—å–Ω–∞—è –∞–ª–ª–æ–∫–∞—Ü–∏—è
    }
}

// ‚úÖ –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è
fn optimized() {
    let mut buffer = String::with_capacity(50000);
    let mut positions = Vec::new();
    
    for i in 0..10000 {
        let start = buffer.len();
        buffer.push_str(&i.to_string());
        positions.push(start);
    }
}
```

## üìù –£–ø—Ä–∞–∂–Ω–µ–Ω–∏—è

1. **–ê–Ω–∞–ª–∏–∑ –ø–∞–º—è—Ç–∏**:
   - –°–æ–∑–¥–∞–π—Ç–µ —Ñ—É–Ω–∫—Ü–∏—é, –ø–æ–∫–∞–∑—ã–≤–∞—é—â—É—é —Ä–∞–∑–º–µ—Ä —Ä–∞–∑–ª–∏—á–Ω—ã—Ö —Ç–∏–ø–æ–≤
   - –ü–æ–∫–∞–∂–∏—Ç–µ –∞–¥—Ä–µ—Å–∞ –Ω–∞ —Å—Ç–µ–∫–µ –∏ –∫—É—á–µ

2. **–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è String**:
   - –°—Ä–∞–≤–Ω–∏—Ç–µ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å String::new() vs String::with_capacity()
   - –ò–∑–º–µ—Ä—å—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä–µ–∞–ª–ª–æ–∫–∞—Ü–∏–π

3. **Custom allocator**:
   - –†–µ–∞–ª–∏–∑—É–π—Ç–µ –ø—Ä–æ—Å—Ç–æ–π stack allocator
   - –°—Ä–∞–≤–Ω–∏—Ç–µ —Å heap allocation

## üìö –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Ä–µ—Å—É—Ä—Å—ã

- [Rust Book - Stack and Heap](https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html#the-stack-and-the-heap)
- [[01_Core/02_Ownership/00_Index|Ownership Index]]
- [[02_Advanced/06_Performance/03_Memory_Layout|Memory Layout]]

---
#rust #memory #stack #heap #ownership #performance
