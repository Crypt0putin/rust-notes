# üìù –®–ø–∞—Ä–≥–∞–ª–∫–∏ –ø–æ Rust

## üéØ –ë—ã—Å—Ç—Ä—ã–µ —Å–ø—Ä–∞–≤–æ—á–Ω–∏–∫–∏

### [[–®–ø–∞—Ä–≥–∞–ª–∫–∏/01_–°–∏–Ω—Ç–∞–∫—Å–∏—Å|üî§ –°–∏–Ω—Ç–∞–∫—Å–∏—Å]]
–û—Å–Ω–æ–≤–Ω—ã–µ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ —è–∑—ã–∫–∞ –Ω–∞ –æ–¥–Ω–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü–µ

### [[–®–ø–∞—Ä–≥–∞–ª–∫–∏/02_–¢–∏–ø—ã|üìä –¢–∏–ø—ã –¥–∞–Ω–Ω—ã—Ö]]
–í—Å–µ —Ç–∏–ø—ã –∏ –∏—Ö –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏

### [[–®–ø–∞—Ä–≥–∞–ª–∫–∏/03_–í–ª–∞–¥–µ–Ω–∏–µ|üîë –í–ª–∞–¥–µ–Ω–∏–µ –∏ –∑–∞–∏–º—Å—Ç–≤–æ–≤–∞–Ω–∏–µ]]
–ü—Ä–∞–≤–∏–ª–∞ –∏ –ø–∞—Ç—Ç–µ—Ä–Ω—ã

### [[–®–ø–∞—Ä–≥–∞–ª–∫–∏/04_–ö–æ–ª–ª–µ–∫—Ü–∏–∏|üìö –ö–æ–ª–ª–µ–∫—Ü–∏–∏]]
–ú–µ—Ç–æ–¥—ã –∏ –æ–ø–µ—Ä–∞—Ü–∏–∏

### [[–®–ø–∞—Ä–≥–∞–ª–∫–∏/05_Cargo|üì¶ –ö–æ–º–∞–Ω–¥—ã Cargo]]
–í—Å–µ –∫–æ–º–∞–Ω–¥—ã –≤ –æ–¥–Ω–æ–º –º–µ—Å—Ç–µ

### [[–®–ø–∞—Ä–≥–∞–ª–∫–∏/06_–û—à–∏–±–∫–∏_–∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–∞|‚ö†Ô∏è –ß–∞—Å—Ç—ã–µ –æ—à–∏–±–∫–∏]]
–†–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–∞ –∏ —Ä–µ—à–µ–Ω–∏—è

## üî§ –û—Å–Ω–æ–≤–Ω–æ–π —Å–∏–Ω—Ç–∞–∫—Å–∏—Å

### –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
```rust
let x = 5;                  // –ù–µ–∏–∑–º–µ–Ω—è–µ–º–∞—è
let mut y = 5;              // –ò–∑–º–µ–Ω—è–µ–º–∞—è
const MAX: u32 = 100_000;   // –ö–æ–Ω—Å—Ç–∞–Ω—Ç–∞
static GLOBAL: &str = "Hi"; // –°—Ç–∞—Ç–∏—á–µ—Å–∫–∞—è

// –ó–∞—Ç–µ–Ω–µ–Ω–∏–µ
let x = x + 1;
let x = x * 2;
```

### –¢–∏–ø—ã –¥–∞–Ω–Ω—ã—Ö
```rust
// –°–∫–∞–ª—è—Ä–Ω—ã–µ
let int: i32 = -42;         // –¶–µ–ª–æ–µ —Å–æ –∑–Ω–∞–∫–æ–º
let uint: u32 = 42;         // –¶–µ–ª–æ–µ –±–µ–∑ –∑–Ω–∞–∫–∞
let float: f64 = 3.14;      // –ü–ª–∞–≤–∞—é—â–∞—è —Ç–æ—á–∫–∞
let boolean: bool = true;    // –ë—É–ª–µ–≤–æ
let character: char = '–ê';   // –°–∏–º–≤–æ–ª (4 –±–∞–π—Ç–∞, Unicode)

// –°–æ—Å—Ç–∞–≤–Ω—ã–µ
let tuple: (i32, f64, u8) = (500, 6.4, 1);
let array: [i32; 5] = [1, 2, 3, 4, 5];
let slice: &[i32] = &array[1..3];
```

### –§—É–Ω–∫—Ü–∏–∏
```rust
fn —Ñ—É–Ω–∫—Ü–∏—è(x: i32, y: i32) -> i32 {
    x + y  // –ë–µ–∑ ; - –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ
}

// –° —Ä–∞–Ω–Ω–∏–º –≤–æ–∑–≤—Ä–∞—Ç–æ–º
fn –ø—Ä–æ–≤–µ—Ä–∫–∞(x: i32) -> i32 {
    if x < 0 {
        return 0;  // –†–∞–Ω–Ω–∏–π –≤–æ–∑–≤—Ä–∞—Ç
    }
    x * 2
}

// Generic —Ñ—É–Ω–∫—Ü–∏—è
fn –Ω–∞–∏–±–æ–ª—å—à–∏–π<T: PartialOrd>(—Å–ø–∏—Å–æ–∫: &[T]) -> &T {
    let mut –Ω–∞–∏–± = &—Å–ø–∏—Å–æ–∫[0];
    for —ç–ª–µ–º–µ–Ω—Ç in —Å–ø–∏—Å–æ–∫ {
        if —ç–ª–µ–º–µ–Ω—Ç > –Ω–∞–∏–± {
            –Ω–∞–∏–± = —ç–ª–µ–º–µ–Ω—Ç;
        }
    }
    –Ω–∞–∏–±
}
```

### –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ—Ç–æ–∫–æ–º
```rust
// if/else
let —á–∏—Å–ª–æ = if —É—Å–ª–æ–≤–∏–µ { 5 } else { 6 };

// loop
let —Ä–µ–∑—É–ª—å—Ç–∞—Ç = loop {
    —Å—á—ë—Ç—á–∏–∫ += 1;
    if —Å—á—ë—Ç—á–∏–∫ == 10 {
        break —Å—á—ë—Ç—á–∏–∫ * 2;
    }
};

// while
while —á–∏—Å–ª–æ != 0 {
    —á–∏—Å–ª–æ -= 1;
}

// for
for —ç–ª–µ–º–µ–Ω—Ç in –∫–æ–ª–ª–µ–∫—Ü–∏—è.iter() {
    // ...
}

for —á–∏—Å–ª–æ in (1..4).rev() {
    println!("{}", —á–∏—Å–ª–æ);
}

// match
match —á–∏—Å–ª–æ {
    1 => println!("–æ–¥–∏–Ω"),
    2 | 3 => println!("–¥–≤–∞ –∏–ª–∏ —Ç—Ä–∏"),
    4..=10 => println!("–æ—Ç —á–µ—Ç—ã—Ä—ë—Ö –¥–æ –¥–µ—Å—è—Ç–∏"),
    _ => println!("—á—Ç–æ-—Ç–æ –¥—Ä—É–≥–æ–µ"),
}

// if let
if let Some(–∑–Ω–∞—á–µ–Ω–∏–µ) = –æ–ø—Ü–∏—è {
    println!("{}", –∑–Ω–∞—á–µ–Ω–∏–µ);
}

// while let
while let Some(–≤–µ—Ä—Ö) = —Å—Ç–µ–∫.pop() {
    println!("{}", –≤–µ—Ä—Ö);
}
```

## üîë –í–ª–∞–¥–µ–Ω–∏–µ - –∫–ª—é—á–µ–≤—ã–µ –ø—Ä–∞–≤–∏–ª–∞

### –¢—Ä–∏ –ø—Ä–∞–≤–∏–ª–∞ –≤–ª–∞–¥–µ–Ω–∏—è
1. **–£ –∫–∞–∂–¥–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è –µ—Å—Ç—å –≤–ª–∞–¥–µ–ª–µ—Ü**
2. **–¢–æ–ª—å–∫–æ –æ–¥–∏–Ω –≤–ª–∞–¥–µ–ª–µ—Ü –≤ –º–æ–º–µ–Ω—Ç –≤—Ä–µ–º–µ–Ω–∏**
3. **–ö–æ–≥–¥–∞ –≤–ª–∞–¥–µ–ª–µ—Ü –≤—ã—Ö–æ–¥–∏—Ç –∏–∑ –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏, –∑–Ω–∞—á–µ–Ω–∏–µ —É–¥–∞–ª—è–µ—Ç—Å—è**

### Move, Clone, Copy
```rust
// Move (–ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ –≤–ª–∞–¥–µ–Ω–∏—è)
let s1 = String::from("hello");
let s2 = s1;  // s1 –±–æ–ª—å—à–µ –Ω–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–∞

// Clone (–≥–ª—É–±–æ–∫–æ–µ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ)
let s1 = String::from("hello");
let s2 = s1.clone();  // –û–±–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –≤–∞–ª–∏–¥–Ω—ã

// Copy (–¥–ª—è –ø—Ä–æ—Å—Ç—ã—Ö —Ç–∏–ø–æ–≤)
let x = 5;
let y = x;  // –û–±–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –≤–∞–ª–∏–¥–Ω—ã (Copy)
```

### –ó–∞–∏–º—Å—Ç–≤–æ–≤–∞–Ω–∏–µ
```rust
// –ù–µ–∏–∑–º–µ–Ω—è–µ–º–æ–µ –∑–∞–∏–º—Å—Ç–≤–æ–≤–∞–Ω–∏–µ
let s = String::from("hello");
let r1 = &s;
let r2 = &s;  // OK: –º–Ω–æ–≥–æ –Ω–µ–∏–∑–º–µ–Ω—è–µ–º—ã—Ö —Å—Å—ã–ª–æ–∫

// –ò–∑–º–µ–Ω—è–µ–º–æ–µ –∑–∞–∏–º—Å—Ç–≤–æ–≤–∞–Ω–∏–µ
let mut s = String::from("hello");
let r1 = &mut s;
// let r2 = &mut s;  // –û–®–ò–ë–ö–ê: —Ç–æ–ª—å–∫–æ –æ–¥–Ω–∞ –∏–∑–º–µ–Ω—è–µ–º–∞—è —Å—Å—ã–ª–∫–∞

// –ü—Ä–∞–≤–∏–ª–∞:
// - –õ–ò–ë–û –æ–¥–Ω–∞ –∏–∑–º–µ–Ω—è–µ–º–∞—è —Å—Å—ã–ª–∫–∞
// - –õ–ò–ë–û –ª—é–±–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –Ω–µ–∏–∑–º–µ–Ω—è–µ–º—ã—Ö —Å—Å—ã–ª–æ–∫
// - –°—Å—ã–ª–∫–∏ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º–∏
```

## üìö –ö–æ–ª–ª–µ–∫—Ü–∏–∏ - –æ—Å–Ω–æ–≤–Ω—ã–µ –º–µ—Ç–æ–¥—ã

### Vec<T>
```rust
// –°–æ–∑–¥–∞–Ω–∏–µ
let mut v = Vec::new();
let v = vec![1, 2, 3];

// –û–ø–µ—Ä–∞—Ü–∏–∏
v.push(4);              // –î–æ–±–∞–≤–∏—Ç—å –≤ –∫–æ–Ω–µ—Ü
v.pop();                // –£–¥–∞–ª–∏—Ç—å —Å –∫–æ–Ω—Ü–∞
v.insert(0, 0);         // –í—Å—Ç–∞–≤–∏—Ç—å –ø–æ –∏–Ω–¥–µ–∫—Å—É
v.remove(0);            // –£–¥–∞–ª–∏—Ç—å –ø–æ –∏–Ω–¥–µ–∫—Å—É
v.clear();              // –û—á–∏—Å—Ç–∏—Ç—å
v.len();                // –î–ª–∏–Ω–∞
v.is_empty();           // –ü—É—Å—Ç–æ–π?
v.contains(&value);     // –°–æ–¥–µ—Ä–∂–∏—Ç?
v.sort();               // –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞
v.reverse();            // –†–µ–≤–µ—Ä—Å

// –î–æ—Å—Ç—É–ø
let third = &v[2];      // –ú–æ–∂–µ—Ç –ø–∞–Ω–∏–∫–æ–≤–∞—Ç—å
let third = v.get(2);   // –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç Option
```

### String
```rust
// –°–æ–∑–¥–∞–Ω–∏–µ
let mut s = String::new();
let s = String::from("hello");
let s = "hello".to_string();

// –ú–æ–¥–∏—Ñ–∏–∫–∞—Ü–∏—è
s.push('!');            // –î–æ–±–∞–≤–∏—Ç—å char
s.push_str(" world");   // –î–æ–±–∞–≤–∏—Ç—å &str
let s3 = s1 + &s2;      // –ö–æ–Ω–∫–∞—Ç–µ–Ω–∞—Ü–∏—è (s1 –ø–µ—Ä–µ–º–µ—â–∞–µ—Ç—Å—è)
let s = format!("{}-{}", s1, s2);  // –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ

// –ú–µ—Ç–æ–¥—ã
s.len();                // –î–ª–∏–Ω–∞ –≤ –±–∞–π—Ç–∞—Ö
s.is_empty();          // –ü—É—Å—Ç–∞—è?
s.contains("ello");    // –°–æ–¥–µ—Ä–∂–∏—Ç –ø–æ–¥—Å—Ç—Ä–æ–∫—É?
s.replace("l", "L");   // –ó–∞–º–µ–Ω–∞
s.to_lowercase();      // –í –Ω–∏–∂–Ω–∏–π —Ä–µ–≥–∏—Å—Ç—Ä
s.trim();              // –£–±—Ä–∞—Ç—å –ø—Ä–æ–±–µ–ª—ã –ø–æ –∫—Ä–∞—è–º
s.split_whitespace();  // –†–∞–∑–±–∏—Ç—å –ø–æ –ø—Ä–æ–±–µ–ª–∞–º

// –ò—Ç–µ—Ä–∞—Ü–∏—è
for c in s.chars() { }  // –ü–æ —Å–∏–º–≤–æ–ª–∞–º
for b in s.bytes() { }  // –ü–æ –±–∞–π—Ç–∞–º
```

### HashMap<K, V>
```rust
use std::collections::HashMap;

// –°–æ–∑–¥–∞–Ω–∏–µ
let mut map = HashMap::new();

// –û–ø–µ—Ä–∞—Ü–∏–∏
map.insert("key", "value");     // –í—Å—Ç–∞–≤–∫–∞
map.get("key");                  // –ü–æ–ª—É—á–µ–Ω–∏–µ Option<&V>
map.remove("key");               // –£–¥–∞–ª–µ–Ω–∏–µ
map.contains_key("key");         // –ï—Å—Ç—å –∫–ª—é—á?
map.len();                       // –†–∞–∑–º–µ—Ä
map.clear();                     // –û—á–∏—Å—Ç–∫–∞

// Entry API
map.entry("key").or_insert(0);  // –í—Å—Ç–∞–≤–∏—Ç—å –µ—Å–ª–∏ –Ω–µ—Ç
*map.entry("key").or_insert(0) += 1;  // –û–±–Ω–æ–≤–∏—Ç—å

// –ò—Ç–µ—Ä–∞—Ü–∏—è
for (key, value) in &map { }
for key in map.keys() { }
for value in map.values() { }
```

## ‚ö†Ô∏è Result –∏ Option

### Option<T>
```rust
enum Option<T> {
    None,
    Some(T),
}

// –ú–µ—Ç–æ–¥—ã
option.is_some();              // true –µ—Å–ª–∏ Some
option.is_none();              // true –µ—Å–ª–∏ None
option.unwrap();               // –ü–∞–Ω–∏–∫—É–µ—Ç –µ—Å–ª–∏ None
option.unwrap_or(default);     // –ó–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
option.unwrap_or_else(|| {});  // –í—ã—á–∏—Å–ª—è–µ–º–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
option.map(|x| x * 2);         // –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ
option.and_then(|x| Some(x));  // flatMap
option.filter(|x| x > &0);     // –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è
option.ok_or("error");         // –í Result
```

### Result<T, E>
```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}

// –ú–µ—Ç–æ–¥—ã
result.is_ok();                // true –µ—Å–ª–∏ Ok
result.is_err();               // true –µ—Å–ª–∏ Err
result.unwrap();               // –ü–∞–Ω–∏–∫—É–µ—Ç –µ—Å–ª–∏ Err
result.unwrap_or(default);     // –ó–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
result.unwrap_or_else(|e| {}); // –í—ã—á–∏—Å–ª—è–µ–º–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
result.expect("msg");          // –ü–∞–Ω–∏–∫—É–µ—Ç —Å —Å–æ–æ–±—â–µ–Ω–∏–µ–º
result.map(|x| x * 2);         // –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ Ok
result.map_err(|e| format!("{}", e)); // –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ Err
result.and_then(|x| Ok(x));    // flatMap
result?;                       // –†–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω–µ–Ω–∏–µ –æ—à–∏–±–∫–∏
```

## üì¶ Cargo –∫–æ–º–∞–Ω–¥—ã

```bash
# –°–æ–∑–¥–∞–Ω–∏–µ –ø—Ä–æ–µ–∫—Ç–∞
cargo new –ø—Ä–æ–µ–∫—Ç           # –ù–æ–≤—ã–π –±–∏–Ω–∞—Ä–Ω—ã–π –ø—Ä–æ–µ–∫—Ç
cargo new --lib –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ # –ù–æ–≤–∞—è –±–∏–±–ª–∏–æ—Ç–µ–∫–∞
cargo init                  # –í —Ç–µ–∫—É—â–µ–π –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏

# –°–±–æ—Ä–∫–∞
cargo build                 # Debug —Å–±–æ—Ä–∫–∞
cargo build --release       # Release —Å–±–æ—Ä–∫–∞
cargo check                 # –ü—Ä–æ–≤–µ—Ä–∫–∞ –±–µ–∑ —Å–±–æ—Ä–∫–∏
cargo clean                 # –û—á–∏—Å—Ç–∫–∞ target/

# –ó–∞–ø—É—Å–∫
cargo run                   # –ó–∞–ø—É—Å–∫ –±–∏–Ω–∞—Ä–Ω–∏–∫–∞
cargo run -- –∞—Ä–≥—É–º–µ–Ω—Ç—ã     # –° –∞—Ä–≥—É–º–µ–Ω—Ç–∞–º–∏
cargo test                  # –ó–∞–ø—É—Å–∫ —Ç–µ—Å—Ç–æ–≤
cargo bench                 # –ó–∞–ø—É—Å–∫ –±–µ–Ω—á–º–∞—Ä–∫–æ–≤

# –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è
cargo doc                   # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏
cargo doc --open           # –û—Ç–∫—Ä—ã—Ç—å –≤ –±—Ä–∞—É–∑–µ—Ä–µ

# –ó–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏
cargo add –ø–∞–∫–µ—Ç            # –î–æ–±–∞–≤–∏—Ç—å (–Ω—É–∂–µ–Ω cargo-edit)
cargo update               # –û–±–Ω–æ–≤–∏—Ç—å –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏
cargo tree                 # –î–µ—Ä–µ–≤–æ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π

# –ö–∞—á–µ—Å—Ç–≤–æ –∫–æ–¥–∞
cargo fmt                  # –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
cargo clippy              # –õ–∏–Ω—Ç–µ—Ä
cargo fix                 # –ê–≤—Ç–æ–∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è

# –ü—É–±–ª–∏–∫–∞—Ü–∏—è
cargo publish             # –û–ø—É–±–ª–∏–∫–æ–≤–∞—Ç—å –Ω–∞ crates.io
cargo install –ø–∞–∫–µ—Ç       # –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∏–∑ crates.io
```

## üéØ –¢—Ä–µ–π—Ç—ã - –æ—Å–Ω–æ–≤–Ω—ã–µ

### –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –≤—ã–≤–æ–¥–∏–º—ã–µ
```rust
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
struct MyStruct { }
```

### Display –∏ Debug
```rust
use std::fmt;

impl fmt::Display for MyType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "MyType: {}", self.value)
    }
}

#[derive(Debug)]  // –ò–ª–∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏
struct MyType { value: i32 }
```

### Iterator
```rust
impl Iterator for MyIterator {
    type Item = i32;
    
    fn next(&mut self) -> Option<Self::Item> {
        // –õ–æ–≥–∏–∫–∞ –∏—Ç–µ—Ä–∞—Ü–∏–∏
    }
}
```

### From –∏ Into
```rust
impl From<i32> for MyType {
    fn from(item: i32) -> Self {
        MyType { value: item }
    }
}
// –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø–æ–ª—É—á–∞–µ–º Into
let my_type: MyType = 5.into();
```

## üîÄ –ü–∞—Ç—Ç–µ—Ä–Ω –º–∞—Ç—á–∏–Ω–≥

```rust
// –ë–∞–∑–æ–≤—ã–π match
match value {
    Pattern1 => expr1,
    Pattern2 | Pattern3 => expr2,
    Pattern4..=Pattern5 => expr3,
    _ => default_expr,
}

// –î–µ—Å—Ç—Ä—É–∫—Ç—É—Ä–∏–∑–∞—Ü–∏—è
let (x, y, z) = (1, 2, 3);

// –°—Ç—Ä—É–∫—Ç—É—Ä—ã
struct Point { x: i32, y: i32 }
let Point { x, y } = point;
let Point { x: a, y: b } = point;  // –ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ

// –ï–Ω—É–º—ã
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
}

match msg {
    Message::Quit => {},
    Message::Move { x, y } => {},
    Message::Write(text) => {},
}

// Guards
match num {
    x if x < 0 => println!("–û—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω–æ–µ"),
    x if x == 0 => println!("–ù–æ–ª—å"),
    _ => println!("–ü–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ"),
}

// @ - –ø—Ä–∏–≤—è–∑–∫–∞
match num {
    n @ 1..=10 => println!("–ß–∏—Å–ª–æ {} –æ—Ç 1 –¥–æ 10", n),
    _ => {},
}
```

## ‚ö° Async/Await –æ—Å–Ω–æ–≤—ã

```rust
// Async —Ñ—É–Ω–∫—Ü–∏—è
async fn fetch_data() -> Result<String, Error> {
    // async –∫–æ–¥
}

// –í—ã–∑–æ–≤
let result = fetch_data().await?;

// Async –±–ª–æ–∫
let future = async {
    let data = fetch_data().await?;
    process(data)
};

// Tokio runtime
#[tokio::main]
async fn main() {
    let result = fetch_data().await;
}
```

## üìä –í—Ä–µ–º–µ–Ω–∞ –∂–∏–∑–Ω–∏

```rust
// –Ø–≤–Ω—ã–µ –∞–Ω–Ω–æ—Ç–∞—Ü–∏–∏
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() { x } else { y }
}

// –°—Ç—Ä—É–∫—Ç—É—Ä—ã —Å –≤—Ä–µ–º–µ–Ω–∞–º–∏ –∂–∏–∑–Ω–∏
struct ImportantExcerpt<'a> {
    part: &'a str,
}

// –ù–µ—Å–∫–æ–ª—å–∫–æ –≤—Ä–µ–º—ë–Ω –∂–∏–∑–Ω–∏
fn foo<'a, 'b>(x: &'a str, y: &'b str) -> &'a str {
    x
}

// 'static –≤—Ä–µ–º—è –∂–∏–∑–Ω–∏
let s: &'static str = "–ñ–∏–≤—ë—Ç –≤—Å—é –ø—Ä–æ–≥—Ä–∞–º–º—É";
```

## üöÄ –ú–∞–∫—Ä–æ—Å—ã

```rust
// –í—ã–∑–æ–≤ –º–∞–∫—Ä–æ—Å–æ–≤
println!("text");           // –° !
vec![1, 2, 3];
format!("{}", value);

// –ü—Ä–æ—Å—Ç–æ–π –º–∞–∫—Ä–æ—Å
macro_rules! say_hello {
    () => {
        println!("Hello!");
    };
}

// –° –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏
macro_rules! create_function {
    ($func_name:ident) => {
        fn $func_name() {
            println!("–§—É–Ω–∫—Ü–∏—è {:?} –≤—ã–∑–≤–∞–Ω–∞", stringify!($func_name));
        }
    };
}
```

## üîß –ü–æ–ª–µ–∑–Ω—ã–µ –∞—Ç—Ä–∏–±—É—Ç—ã

```rust
#[derive(Debug, Clone)]        // –ê–≤—Ç–æ–≤—ã–≤–æ–¥ —Ç—Ä–µ–π—Ç–æ–≤
#[allow(dead_code)]            // –†–∞–∑—Ä–µ—à–∏—Ç—å –Ω–µ–∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–π –∫–æ–¥
#[warn(unused_variables)]      // –ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ
#[deny(unsafe_code)]           // –ó–∞–ø—Ä–µ—Ç–∏—Ç—å unsafe
#[cfg(test)]                   // –¢–æ–ª—å–∫–æ –¥–ª—è —Ç–µ—Å—Ç–æ–≤
#[cfg(target_os = "linux")]    // –£—Å–ª–æ–≤–Ω–∞—è –∫–æ–º–ø–∏–ª—è—Ü–∏—è
#[inline]                      // –ü–æ–¥—Å–∫–∞–∑–∫–∞ –¥–ª—è –∏–Ω–ª–∞–π–Ω–∏–Ω–≥–∞
#[must_use]                    // –†–µ–∑—É–ª—å—Ç–∞—Ç –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω
#[deprecated]                  // –£—Å—Ç–∞—Ä–µ–≤—à–µ–µ
```

---
#rust #—à–ø–∞—Ä–≥–∞–ª–∫–∞ #—Å–ø—Ä–∞–≤–æ—á–Ω–∏–∫ #—Å–∏–Ω—Ç–∞–∫—Å–∏—Å #–±—ã—Å—Ç—Ä—ã–π_–¥–æ—Å—Ç—É–ø
